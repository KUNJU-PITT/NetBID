---
title: "QC plot for eSet"
output: 
  html_document
---

```{r include=FALSE}
library(NetBID2)
library(kableExtra)
draw.meanSdPlot <- function(eset){
    exp_mat <- exprs(eset)
    mean_g <- apply(exp_mat,1,mean)
    mean_g <- rank(mean_g)
    sd_g <- apply(exp_mat,1,sd)
    n <- 50
    mean_g_c <- cut(mean_g,breaks = n)
    sd_g_c <- cut(sd_g,breaks = n)
    mat <- table(cbind(list(mean_g_c,sd_g_c)))
    tmp1 <- aggregate(sd_g,list(mean_g_c),mean); rownames(tmp1) <- tmp1$Group.1
    sd_g_v <- tmp1[levels(mean_g_c),'x']
    #
    mean_g_l <- t(sapply(levels(mean_g_c),function(x)as.numeric(strsplit(gsub('\\(|\\]','\\1',x),',')[[1]])))
    sd_g_l <- t(sapply(levels(sd_g_c),function(x)as.numeric(strsplit(gsub('\\(|\\]','\\1',x),',')[[1]])))
    mean_g_l_m <- rowMeans(mean_g_l)
    sd_g_l_m <- rowMeans(sd_g_l)
    # col=get_transparent(brewer.pal(8,'Set1')[2],alpha=0.1)
    par(mai=c(1,1,1,2))
    dat <- spline(x=mean_g_l_m,y=sd_g_v,n=n*10)
    plot(y~x,data=dat,type='l',col=brewer.pal(8,'Set1')[1],lwd=2,xlab='rank(mean)',ylab='sd',
         ylim=c(0,max(sd_g)),xlim=c(0,max(mean_g)),cex.lab=1.2)
    pp <- par()$usr
    ##
    ag <- 30
    r <- max(mean_g)/(2*nrow(mat))
    rx <- r/cos(ag*pi/180)*par.pos2inch()[1] # x-inch
    ry <- rx
    x1 <- c(rx*cos(ag*pi/180),rx*cos(ag*pi/180),0,-rx*cos(ag*pi/180),-rx*cos(ag*pi/180),0,rx*cos(ag*pi/180))
    y1 <- c(ry*sin(ag*pi/180),-ry*sin(ag*pi/180),-ry,-ry*sin(ag*pi/180),+ry*sin(ag*pi/180),ry,ry*sin(ag*pi/180))
    #print(x1/par.pos2inch()[1]);print(y1/par.pos2inch()[2])
    simplehexbin <- function(x,y,r,col){
       polygon(x=x+x1/par.pos2inch()[1],y=y+y1/par.pos2inch()[2],col=col,border = 'white',lwd=0.1)
    }
    mm <- max(as.numeric(mat))
    cc <- colorRampPalette(brewer.pal(9,'Blues')[c(2:9)])(mm)
    cc <- rev(cc)
    for(i in 1:nrow(mat)){
      for(j in 1:ncol(mat)){
        if(mat[i,j]>0){
          if(j%%2==0) simplehexbin(x=mean_g_l_m[i],y=sd_g_l_m[j],col=cc[mat[i,j]])
          if(j%%2==1) simplehexbin(x=mean_g_l_m[i]-r,y=sd_g_l_m[j],col=cc[mat[i,j]])
        }
      }
    }
    lines(y~x,data=dat,col=brewer.pal(8,'Set1')[1],lwd=2)
    ypos <- seq(pp[4]-par.char2pos()[2]*2,pp[3]+(pp[4]-pp[3])/2,length.out=length(cc)+1)
    text(x=pp[2]+par.char2pos()[1]*1.5,y=pp[4]-par.char2pos()[2],pos=4,'Count',xpd=TRUE)
    rect(xleft=pp[2]+par.char2pos()[1],xright=pp[2]+par.char2pos()[1]*1.5,ybottom=ypos[1:(length(ypos)-1)],ytop=ypos[2:length(ypos)],col=rev(cc),border=NA,xpd=TRUE)
    text(x=pp[2]+par.char2pos()[1]*1.5,y=quantile(ypos,probs=c(0,0.5,1)),c(1,round(mm/2),mm),xpd=TRUE,pos=4)
    return(TRUE)
  }
```

```{r echo=FALSE}
dt <- pData(eset)
if(nrow(dt)<20){
kable(dt,align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "100%")
}else{
  kable(dt,align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "500px")
}
```


This eSet contains `r nrow(use_mat)` probes/transcripts/genes in `r ncol(use_mat)` samples, 
in which `r length(intgroup)` sample class: `r intgroup` will used for basic clustering analysis.

## Part I: Heatmap between samples

Distance between samples is calculated by dist2().

```{r echo=FALSE,fig.width=12, fig.height=12}
nrow <- ceiling(length(intgroup)/2)
par(mfrow = c(nrow, 2))
par(mar = c(6, 6, 6, 6))
    m <- dist2(use_mat)
    #dend <- as.dendrogram(hclust(as.dist(m), method = "single"))
    #ord <- order.dendrogram(dend)
    #m <- m[ord, ord]
    res <- draw.heatmap(mat=m,phenotype_info = pData(eset),use_phe=intgroup)
```

## Part II: PCA plot for samples

Original expression matrix is transformed by PCA (principal component analysis) and the first two components are visualized.  

```{r echo=FALSE, fig.width=12, fig.height=6}
nrow <- ceiling(length(intgroup)/2)
par(mfrow = c(nrow, 2))
   pca <- prcomp(t(na.omit(use_mat)))
   for (i in 1:length(intgroup)) {
      class_label <- pData(eset)[,intgroup[i]]
      class_label[which(is.na(class_label)==TRUE)] <- 'NA'
      par(mar = c(3, 2, 3, 4))
      draw.2D(as.data.frame(pca$x)$PC1,as.data.frame(pca$x)$PC2,class_label=class_label,
              xlab=sprintf('PC1(%s%s variance)',format(summary(pca)$importance[2,'PC1']*100,digits=3),'%'),
              ylab=sprintf('PC2(%s%s variance)',format(summary(pca)$importance[2,'PC2']*100,digits=3),'%'),
              legend_cex=0.8,main=sprintf('%s',intgroup[i]))
      par(mar = c(3, 2, 3, 2))
      draw.2D.ellipse(as.data.frame(pca$x)$PC1,as.data.frame(pca$x)$PC2,class_label=class_label,
                      xlab=sprintf('PC1(%s%s variance)',format(summary(pca)$importance[2,'PC1']*100,digits=3),'%'),
                      ylab=sprintf('PC2(%s%s variance)',format(summary(pca)$importance[2,'PC2']*100,digits=3),'%'),
                      legend_cex=0.8,main=sprintf('%s',intgroup[i]))
    }
```

## Part III: Density plot

The density for the expression value in each sample is ploted with colored grouped by the sample class. 

```{r echo=FALSE ,fig.width=12, fig.height=8}
nrow <- ceiling(length(intgroup)/2)
par(mfrow = c(nrow, 2))
par(mar = c(3, 3, 3, 3))
for(i in 1:length(intgroup)){
      all_dens <- list()
      for (j in 1:ncol(use_mat)) {
        all_dens[[j]] <- density(use_mat[,j],na.rm=TRUE)
      }
      plot(1,col = 'white',xlim=c(min(unlist(lapply(all_dens,function(x)min(x$x)))),max(unlist(lapply(all_dens,function(x)max(x$x))))),
           type = 'l',xlab = "",ylab='Density',main = sprintf('Density plot for %s',intgroup[i]),
           ylim=c(min(unlist(lapply(all_dens,function(x)min(x$y)))),max(unlist(lapply(all_dens,function(x)max(x$y))))))
      class_label <- pData(eset)[,intgroup[i]]
      cls_cc <- get.class.color(class_label)
      for (j in 1:ncol(use_mat)) {
        lines(all_dens[[j]], col = cls_cc[j])
      }
      legend('topright',legend=unique(class_label),
             fill = cls_cc[unique(class_label)],
             xpd = TRUE,border = NA,bty = 'n',horiz = FALSE)
    }
```

## Part IV: MeanSd plot

The standard deviations versus means for each probe/transcript/gene is plotted. 

```{r echo=FALSE,fig.width=8, fig.height=8}
    draw.meanSdPlot(eset)
```




