---
title: "QC plot for network generated by SJAracne"
output: 
  html_document
---

```{r include=FALSE}
library(NetBID2)
library(kableExtra)
```

```{r echo=FALSE}
deg <- igraph::degree(net,mode='out')
source_list <- names(deg)[which(deg>0)]
c1 <- components(net)
if(weighted==TRUE) edge_weight <- E(net)$weight else edge_weight<-NULL
```


## Part I: Basic statistics

This network is `r ifelse(directed==TRUE,'a directed','an undirected')` and `r ifelse(weighted==TRUE,'weighted','unweighted')` network, 
which contains `r length(V(net))` nodes and `r length(E(net))` edges.
This network contains `r c1$no` connected components, in which the largest component size is `r c1$csize`.
In total `r length(source_list)` nodes are possible drivers.


```{r include=FALSE}
net_statistic <- list()
net_detail    <- list()

## global network
net_statistic$edge_density <- edge_density(net, loops=F);  ## The density of a graph is the ratio of the number of edges and the number of possible edges.
net_statistic$diameter <- diameter(net, directed=directed, weights=edge_weight) ## The diameter of a graph is the length of the longest geodesic.
net_statistic$mean_distance <- mean_distance(net,directed=directed)
  
## nodes
# degree
if(directed==TRUE) c1 <- igraph::degree(net, mode="out", normalized=FALSE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) c2 <- igraph::degree(net, mode="in", normalized=FALSE) ## Centralize a graph according to the degrees of vertices
c3 <- igraph::degree(net, mode="all", normalized=FALSE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) net_detail$degree_out <- c1
if(directed==TRUE) net_detail$degree_in  <- c2
net_detail$degree_all <- c3

# centralized degree
if(directed==TRUE) c1 <- centr_degree(net, mode="out", normalized=TRUE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) c2 <- centr_degree(net, mode="in", normalized=TRUE) ## Centralize a graph according to the degrees of vertices
c3 <- centr_degree(net, mode="all", normalized=TRUE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) net_statistic$degree_out_centrality <- c1$centralization
if(directed==TRUE) net_statistic$degree_in_centrality  <- c2$centralization
net_statistic$degree_all_centrality <- c3$centralization
if(directed==TRUE) net_detail$centr_degree_out <- c1$res
if(directed==TRUE) net_detail$centr_degree_in  <- c2$res
net_detail$centr_degree_all <- c3$res

# closeness
if(directed==TRUE) c1 <- closeness(net, mode="out", weights=edge_weight, normalized=FALSE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) c2 <- closeness(net, mode="in", weights=edge_weight, normalized=FALSE) ## Centralize a graph according to the degrees of vertices
c3 <- closeness(net, mode="all", weights=edge_weight, normalized=FALSE) ## Centralize a graph according to the degrees of vertices
if(directed==TRUE) net_detail$closeness_out <- c1
if(directed==TRUE) net_detail$closeness_in  <- c2
net_detail$closeness_all <- c3

# Closeness centrality of vertices
if(directed==TRUE) c1 <- centr_clo(net,mode='out')
if(directed==TRUE) c2 <- centr_clo(net,mode='in')
c3 <- centr_clo(net,mode='all')
if(directed==TRUE) net_statistic$closeness_out_centrality <- c1$centralization
if(directed==TRUE) net_statistic$closeness_in_centrality  <- c2$centralization
net_statistic$closeness_all_centrality <- c3$centralization
if(directed==TRUE) net_detail$centr_closeness_out <- c1$res
if(directed==TRUE) net_detail$centr_closeness_in  <- c2$res
net_detail$centr_closeness_all <- c3$res

# Find Eigenvector Centrality Scores of Network Positions
c1 <- eigen_centrality(net,directed=directed,weights = edge_weight)
net_statistic$eigen_centrality_scores <- c1$value # The eigenvalue corresponding to the calculated eigenvector, i.e. the centrality scores.
net_detail$eigen_centrality_scores <- c1$vector

# Centralize a graph according to the eigenvector centrality of vertices
c1 <- centr_eigen(net,directed=directed,normalized = TRUE)
net_statistic$eigen_centrality <- c1$centralization # The graph level centrality index.
net_detail$eigen_centrality <- c1$vector

# Vertex and edge betweenness centrality
c1 <- betweenness(net,directed=directed,weights = edge_weight)
net_detail$vertex_betweenness <- c1
c1 <- centr_betw(net, directed=directed, normalized=TRUE)
net_statistic$betweenness_centrality <- c1$centralization # The graph level centrality index.
net_detail$betweenness_centrality <- c1$res

# hub score
c1 <- hub_score(net,weights=edge_weight)
net_statistic$hub_centrality <- c1$value # The hub scores of the vertices are defined as the principal eigenvector of A*t(A), where A is the adjacency matrix of the graph.
net_detail$hub_centrality <- c1$vector

# authority_score
c1 <- authority_score(net,weights=edge_weight)
net_statistic$authority_centrality <- c1$value # The hub scores of the vertices are defined as the principal eigenvector of A*t(A), where A is the adjacency matrix of the graph.
net_detail$authority_centrality <- c1$vector

# pagerank
c1 <- page_rank(net,directed=directed,weights = edge_weight) # Calculates the Google PageRank for the specified vertices.
net_statistic$page_rank_score <- c1$value # The graph level centrality index.
net_detail$page_rank_score <- c1$vector

## edges
net_edge_detail <- list()
c1 <- edge_betweenness(net,directed=directed,weights = edge_weight)
names(c1) <- attr(E(net),'vnames')
net_edge_detail$edge_betweenness <- c1

dt <- as.data.frame(unlist(net_statistic))
colnames(dt) <- 'Value'

```

```{r echo=FALSE}
kable(dt,align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "100%")
```

## Part II: Detailed statistics for drivers

Detailed statistics for all `r length(source_list)` drivers. 

```{r echo=FALSE}
dt <- do.call(cbind,net_detail)
dt1 <- dt[source_list,]
if(nrow(dt1)<20){
kable(dt1,align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "100%")
}else{
  kable(dt1,align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "500px")
}

```


## Part III: Scale free distribution checking

```{r echo=FALSE, fig.width=12, fig.height=10}
check_scalefree <- function(igraph_obj) {
  gr1 <- igraph_obj
  fp1 <- degree_distribution(gr1)
  dd <- as.data.frame(cbind(k = 1:max(igraph::degree(gr1)), pk = fp1[-1]))
  r2 <-
    lm(log(dd$pk + 1 / length(V(gr1))) ~ log(dd$k))
  r3 <- summary(r2)$adj.r.squared
  plot(pk ~ k,data = dd,log = 'xy',main = sprintf('R2:%f', r3))
  return(r3)
}
plot(density(igraph::degree(net)),xlab='Degree',main=sprintf('Density plot for degree distribution \n (network node:%d, network edge:%d)',length(V(net)),length(E(net))));
hist(igraph::degree(net),xlab='Degree',main='Histogram of degree')
res1 <- check_scalefree(net)
```



