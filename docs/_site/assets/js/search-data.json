{
  "0": {
    "id": "0",
    "title": "Advanced analysis",
    "content": "Advanced analysis The purpose for this part: further analyze and visualize the results for drivers. The full demo script for this part could be found in analysis_and_plot_demo1.R. In this part, we will use the question-induced strategy to assist user for the choice and usage of those visualization functions. The main purpose is that we want to find potential hidden drivers in Group4 compared with the other subtypes by using NetBID2, for which may be related with the specific clinical feature for Group4 MB. Preparations Library the installed NetBID2, set the directory to get the pre-saved RData in the ms-tab step. Here, we could use the demo in NetBID2 package. Print the analysis.par$out.dir.PLOT to get know where the plot figures will be saved. User could also choose to change to another local writable path. # library the package library(NetBID2) # set the directory to get the pre-saved RData analysis.par &lt;- list() analysis.par$out.dir.DATA &lt;- system.file(&#39;demo1&#39;,&#39;driver/DATA/&#39;,package = &quot;NetBID2&quot;) NetBID.loadRData(analysis.par=analysis.par,step=&#39;ms-tab&#39;) print(analysis.par$out.dir.PLOT) #analysis.par$out.dir.PLOT &lt;- &#39;test/driver/PLOT&#39; ## directory to save the plot figures Part I: for the top list of significant drivers QI.1: How to get the top list of drivers with significantly different activity (DA) in G4 Vs. other subtypes ? For simplicity, save the final master table to another variable ms_tab and set the comparison name comp_name. Here we choose the G4.Vs.others as the demo. Before detailed analysis, the target size for the driver could be used as a filteration, drivers with too small target size (e.g &lt;30) or too large target size (e.g &gt;1000) will not be used. ms_tab &lt;- analysis.par$final_ms_tab ## get the master table data frame ms_tab &lt;- ms_tab[which(ms_tab$Size&gt;=30 &amp; ms_tab$Size &lt;=1000),] ## target size filteration comp_name &lt;- &#39;G4.Vs.others&#39; ## get the comparison name We will use draw.volcanoPlot() to get the list of top DA drivers and plot the results. The input is the data frame containing the columns of label_col, logFC_col and Pv_col. User need to input the threshold for logFC (logFC_thre) and P.Value (Pv_thre). This function could choose not to display figures by setting show_plot=FALSE and only output the list of significant top drivers. If choose show_label=TRUE, the number of the drivers passed the threshold may not be very high as too many labels displayed on the figure will become a mess. For the activity value, the threshold for logFC may not be very high especially setting std=TRUE in cal.Activity(). Top drivers with DA passed absolute logFC≥0.4 and P-value≤1e-8, with detailed label information are shown: sig_driver &lt;- draw.volcanoPlot(dat=ms_tab,label_col=&#39;gene_label&#39;,logFC_col=sprintf(&#39;logFC.%s_DA&#39;,comp_name), Pv_col=sprintf(&#39;P.Value.%s_DA&#39;,comp_name),logFC_thre=0.4,Pv_thre=1e-8, main=sprintf(&#39;Volcano Plot for %s_DA&#39;,comp_name),show_label=TRUE, pdf_file=sprintf(&#39;%s/vocalno_label_DA.pdf&#39;,analysis.par$out.dir.PLOT),label_cex = 1) Volcano plot is also applicable for get the top DE genes. Top genes with DE passed absolute logFC≥1.5 and P-value≤1e-4 are shown: sig_gene &lt;- draw.volcanoPlot(dat=ms_tab,label_col=&#39;geneSymbol&#39;,logFC_col=sprintf(&#39;logFC.%s_DE&#39;,comp_name), Pv_col=sprintf(&#39;P.Value.%s_DE&#39;,comp_name),logFC_thre=1.5,Pv_thre=1e-4, main=sprintf(&#39;Volcano Plot for %s_DE&#39;,comp_name),show_label=TRUE, pdf_file=sprintf(&#39;%s/vocalno_label_DE.pdf&#39;,analysis.par$out.dir.PLOT),label_cex = 1) sig_driver and sig_gene are the data frame containing drivers and genes passed the threshold with detailed logFC and P.value statistics. QI.2: How to understand the significance of those top DA drivers ? Those drivers are significant due to their activity difference in Group4 Vs. other subtypes. The activity is calculated based on the expression pattern of their target genes. If the driver’s activity is significantly up-regulated in Group4, which means that its positively regulated target genes are significantly up-regulated in Group4 and negative target genes are down-regulated. Based on this, we could use draw.GSEA.NetBID() to visualize this trend for top drivers. This function has more than 10 options, check the manual for detail by ?draw.GSEA.NetBID. First, the differentiated expression (DE) profile in Group4 Vs. others should be used to estimate the performance of the target genes. And driver_list need to be the originalID_label in the master table as it is the only unique column. In the above volcano plot, the rownames for the output data frame will be the rownames from the original master table, i.e the originalID_label. DE &lt;- analysis.par$DE[[comp_name]] driver_list &lt;- rownames(sig_driver) ## the rownames is the originalID_label The following figures differ in the option of profile_trend, profile_col, target_nrow, target_col, target_col_type. In the first demo plot, the profile (above part of the figure) is from negative values to positive values (profile_trend=&#39;neg2pos&#39;), indicating the logFC (set in profile_col) value for genes. The position for the genes are consistent in the profile figure and the GSEA-pattern figure (below part of the figure). Each vertical line in each row stands for one target gene for the corresponding driver. The target genes for one driver will be separated into positive-regulated sets and negative-regulated sets (target_nrow=2). The color for those target genes are the significance in the profile (target_col_type=&#39;DE&#39;), with value passed the profile_sig_thre color in blue (negative value) and red (positive value). We could study from the figure that, the positively regulated target genes for the down DA drivers tend to lay in the left part of the profile and the negatively regulated in the right part. Contrary trend for up DA drivers. draw.GSEA.NetBID(DE=DE,profile_col=&#39;logFC&#39;,profile_trend=&#39;neg2pos&#39;,name_col=&#39;ID&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DA&#39;], driver_DE_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DE&#39;], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=2,target_col=&#39;RdBu&#39;, left_annotation = &#39;high in others&#39;,right_annotation = &#39;high in G4&#39;, main=comp_name,target_col_type=&#39;DE&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo1.pdf&#39;,analysis.par$out.dir.PLOT)) In the second demo plot,the profile is from positive values to negative values (profile_trend=&#39;pos2neg&#39;), indicating the t (set in profile_col) value for genes. The color for those target genes are the same for positively-regulaion or negatively-regulation (target_col_type=&#39;PN&#39;) draw.GSEA.NetBID(DE=DE,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DA&#39;], driver_DE_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DE&#39;], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=2,target_col=&#39;RdBu&#39;, left_annotation = &#39;high in G4&#39;,right_annotation = &#39;high in others&#39;, main=comp_name,target_col_type=&#39;PN&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo2.pdf&#39;,analysis.par$out.dir.PLOT)) In the third demo plot, the color for those target genes are just black (target_col=&#39;black&#39;). draw.GSEA.NetBID(DE=DE,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DA&#39;], driver_DE_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DE&#39;], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=2,target_col=&#39;black&#39;, left_annotation = &#39;high in G4&#39;,right_annotation = &#39;high in others&#39;, main=comp_name,target_col_type=&#39;PN&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo3.pdf&#39;,analysis.par$out.dir.PLOT)) In the forth demo plot, the positively-regulaion or negatively-regulation is not separately into two rows (target_nrow = 1), target_col=&#39;RdBu&#39; and target_col_type=&#39;DE&#39;. draw.GSEA.NetBID(DE=DE,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DA&#39;], driver_DE_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DE&#39;], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=1,target_col=&#39;RdBu&#39;, left_annotation = &#39;high in G4&#39;,right_annotation = &#39;high in others&#39;, main=comp_name,target_col_type=&#39;DE&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo4.pdf&#39;,analysis.par$out.dir.PLOT)) In the fifth demo plot, the positively-regulaion or negatively-regulation is not separately into two rows (target_nrow = 1) and target_col=&#39;black&#39;. draw.GSEA.NetBID(DE=DE,profile_col=&#39;t&#39;,profile_trend=&#39;pos2neg&#39;, driver_list = driver_list, show_label=ms_tab[driver_list,&#39;gene_label&#39;], driver_DA_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DA&#39;], driver_DE_Z=ms_tab[driver_list,&#39;Z.G4.Vs.others_DE&#39;], target_list=analysis.par$merge.network$target_list, top_driver_number=30,target_nrow=1,target_col=&#39;black&#39;, left_annotation = &#39;high in G4&#39;,right_annotation = &#39;high in others&#39;, main=comp_name,target_col_type=&#39;PN&#39;,Z_sig_thre=1.64,profile_sig_thre = 1.64, pdf_file=sprintf(&#39;%s/NetBID_GSEA_demo5.pdf&#39;,analysis.par$out.dir.PLOT)) QI.3: What is the expression/activity pattern of those top DA drivers in samples with different subtype ? Next, we’d like to know the expression/activity pattern for those top DA drivers in different group of samples, the most straightforward strategy is to use heatmap. In NetBID2, draw.heatmap() is designed to assist simple usage of heatmap. It is based on Heatmap() function in ComplexHeatmap. Get the expression matrix exp_mat and activity matrix ac_mat from analysis.par, and phenotype data frame phe_info. exp_mat &lt;- exprs(analysis.par$cal.eset) ## expression,the rownames must be the originalID ac_mat &lt;- exprs(analysis.par$merge.ac.eset) ## ac,the rownames must be the originalID_label phe_info &lt;- pData(analysis.par$cal.eset) # could use addtional paramters in Heatmap() Draw the expression value (scaled by samples scale=&#39;row&#39;) for top DA drivers across all samples and display the sample class label above. Here, the use_genes must be the originalID. User could directly input phenotype_info=phe_info and choose which columns to display in use_phe. draw.heatmap(mat=exp_mat,use_genes=ms_tab[driver_list,&#39;originalID&#39;],use_gene_label=ms_tab[driver_list,&#39;geneSymbol&#39;], use_samples=colnames(exp_mat),use_sample_label=phe_info[colnames(exp_mat),&#39;geo_accession&#39;], phenotype_info=phe_info,use_phe=c(&#39;gender&#39;,&#39;pathology&#39;,&#39;subgroup&#39;,&#39;age&#39;),main=&#39;Expression for Top drivers&#39;,scale=&#39;row&#39;, cluster_rows=TRUE,cluster_columns=TRUE,clustering_distance_rows=&#39;pearson&#39;,clustering_distance_columns=&#39;pearson&#39;, row_names_gp = gpar(fontsize = 12),pdf_file=sprintf(&#39;%s/heatmap_demo1.pdf&#39;,analysis.par$out.dir.PLOT)) Draw the activity value for top DA drivers, here, the use_genes must be the originalID_label but user could to display label in the gene_label column. In this demo, the original label is also gene symbol, but in some cases the original label maybe the ensemble_gene_id, the originalID will be different and user could choose to display the gene symbol in gene_label (set by use_gene_label). draw.heatmap(mat=ac_mat,use_genes=driver_list,use_gene_label=ms_tab[driver_list,&#39;gene_label&#39;], use_samples=colnames(exp_mat),use_sample_label=phe_info[colnames(exp_mat),&#39;geo_accession&#39;], phenotype_info=phe_info,use_phe=c(&#39;gender&#39;,&#39;pathology&#39;,&#39;subgroup&#39;,&#39;age&#39;),main=&#39;Activity for Top drivers&#39;,scale=&#39;row&#39;, cluster_rows=TRUE,cluster_columns=TRUE,clustering_distance_rows=&#39;pearson&#39;,clustering_distance_columns=&#39;pearson&#39;, row_names_gp = gpar(fontsize = 12),pdf_file=sprintf(&#39;%s/heatmap_demo2.pdf&#39;,analysis.par$out.dir.PLOT)) Compared with the two figures above, the activity pattern is much more clean than the expression pattern for top DA drivers, and also for top DE drivers (figures not shown here, but demo script is below), suggesting that the activity of drivers may be more robust in separating specific sample groups. # try for the top DE genes gene_list &lt;- rownames(sig_gene) draw.heatmap(mat=exp_mat,use_genes=ms_tab[gene_list,&#39;originalID&#39;],use_gene_label=ms_tab[gene_list,&#39;geneSymbol&#39;], use_samples=colnames(exp_mat),use_sample_label=phe_info[colnames(exp_mat),&#39;geo_accession&#39;], phenotype_info=phe_info,use_phe=c(&#39;gender&#39;,&#39;pathology&#39;,&#39;subgroup&#39;,&#39;age&#39;),main=&#39;Expression for Top drivers&#39;,scale=&#39;row&#39;, cluster_rows=TRUE,cluster_columns=TRUE,clustering_distance_rows=&#39;pearson&#39;,clustering_distance_columns=&#39;pearson&#39;, row_names_gp = gpar(fontsize = 12),pdf_file=sprintf(&#39;%s/heatmap_demo3.pdf&#39;,analysis.par$out.dir.PLOT)) draw.heatmap(mat=ac_mat,use_genes= gene_list,use_gene_label=ms_tab[gene_list,&#39;gene_label&#39;], use_samples=colnames(exp_mat),use_sample_label=phe_info[colnames(exp_mat),&#39;geo_accession&#39;], phenotype_info=phe_info,use_phe=c(&#39;gender&#39;,&#39;pathology&#39;,&#39;subgroup&#39;,&#39;age&#39;),main=&#39;Activity for Top drivers&#39;,scale=&#39;row&#39;, cluster_rows=TRUE,cluster_columns=TRUE,clustering_distance_rows=&#39;pearson&#39;,clustering_distance_columns=&#39;pearson&#39;, row_names_gp = gpar(fontsize = 12),pdf_file=sprintf(&#39;%s/heatmap_demo4.pdf&#39;,analysis.par$out.dir.PLOT)) QI.4: What is the biological function of those top DA drivers ? In order to study the function of those drivers, we could import curated gene sets from MSigDB. NetBID2 has provided one function gs.preload() to automatically download curated gene sets from MSigDB (based on msigdbr). The only input is the species name, full list of available species name could be found by msigdbr_show_species(). Default is ‘Homo sapiens’. The dataset for human is already packed in NetBID2 R package. Similar as db.preload(), if leave main.dir=NULL, the RData will be saved to system.file(package = &quot;NetBID2&quot;)/db/. If NetBID2 is installed in a public place with no permission to user, just set main.dir to another place and remember to use the same path next time using it. User can print all_gs2gene_info to check the detailed information of the global variable all_gs2gene. The column Category and Sub-Category will be used as the label to extract categories of gene sets for use. # load RData for all_gs2gene gs.preload(use_spe=&#39;Homo sapiens&#39;,update=FALSE) print(all_gs2gene_info) Now, user could choose to use the pre-loaded gene sets to perform Fisher based Gene Set enrichment analysis by funcEnrich.Fisher(). The input_list and bg_list must be the gene symbol. This is easily obtained by using the geneSymbol column in the master table. gs2gene is the list for geneset to genes, the name for the list is the gene set name and the content in each list is the vector for genes belong to that gene set. If NULL, will use all_gs2gene loaded by using gs.preload(). User do not need to prepare this if want to use MSigDB. use_gs is the vector of category name used in analysis, this could be the mixture of category names from Category and Sub-Category. Do not worry about the redundant issue, all gene sets will be passed into merge_gs() and the gene sets with the same gene set name will be merged. res_up &lt;- funcEnrich.Fisher(input_list=ms_tab[driver_list_up,&#39;geneSymbol&#39;],bg_list=unique(ms_tab[,&#39;geneSymbol&#39;]),use_gs=c(&#39;H&#39;,&#39;CP:REACTOME&#39;,&#39;BP&#39;,&#39;CGP&#39;), Pv_thre=0.1,Pv_adj = &#39;none&#39;,min_gs_size = 30, max_gs_size = 500) res_down &lt;- funcEnrich.Fisher(input_list=ms_tab[driver_list_down,&#39;geneSymbol&#39;],bg_list=unique(ms_tab[,&#39;geneSymbol&#39;]),use_gs=c(&#39;H&#39;,&#39;CP:REACTOME&#39;,&#39;BP&#39;,&#39;CGP&#39;), Pv_thre=0.1,Pv_adj = &#39;none&#39;,min_gs_size = 30, max_gs_size = 500) funcEnrich.Fisher() will return detailed results for enrichment analysis, use ?funcEnrich.Fisher to check the detail. And the results could be output to excel file by out2excel(). out2excel(list(up=res_up,down=res_down),out.xlsx=sprintf(&#39;%s/fisher_res.xlsx&#39;,analysis.par$out.dir.PLOT)) Meanwhile, the enrichment analysis results can be visualized by barplot (draw.funcEnrich.bar()) and cluster plot (draw.funcEnrich.cluster()). The barplot is a simply way to display the enriched P-value, with the example of intersected genes (if set display_genes=TRUE). # draw barplot draw.funcEnrich.bar(funcEnrich_res= res_up,top_number=30,main=&#39;Function Enrichment for Top drivers&#39;,pdf_file=sprintf(&#39;%s/funcEnrich_bar_nogene.pdf&#39;,analysis.par$out.dir.PLOT)) draw.funcEnrich.bar(funcEnrich_res= res_up,top_number=30,main=&#39;Function Enrichment for Top drivers&#39;,display_genes = TRUE,gs_cex=0.6, pdf_file=sprintf(&#39;%s/funcEnrich_bar_withgene.pdf&#39;,analysis.par$out.dir.PLOT)) Considering the function redudancy of gene sets and the cluster of genes by function similarity, the function cluster plot could be used. draw.funcEnrich.cluster(funcEnrich_res= res_up,top_number=30,gs_cex = 1.4,gene_cex=1.5,pv_cex=1.2,pdf_file = sprintf(&#39;%s/funcEnrich_clusterBOTH.pdf&#39;,analysis.par$out.dir.PLOT), cluster_gs=TRUE,cluster_gene = TRUE,h=0.95) In the figure below, top 30 enriched terms could be clustered into 6 clusters (cluster size adjusted by h). We could easily get to know the related genes for each function clusters. Here, top enriched gene sets are related with lipid biosynthetic process, with detailed description from: e.g ‘GO_LIPID_BIOSYNTHETIC_PROCESS’ Try the below scripts and check the difference of the output figure: draw.funcEnrich.cluster(funcEnrich_res= res_up,top_number=30,gs_cex = 0.8,gene_cex=0.9,pv_cex=0.8,pdf_file = sprintf(&#39;%s/funcEnrich_clusterGS.pdf&#39;,analysis.par$out.dir.PLOT), cluster_gs=TRUE,cluster_gene = FALSE) draw.funcEnrich.cluster(funcEnrich_res= res_up,top_number=30,gs_cex = 0.8,gene_cex=0.9,pv_cex=0.8,pdf_file = sprintf(&#39;%s/funcEnrich_clusterGENE.pdf&#39;,analysis.par$out.dir.PLOT), cluster_gs=FALSE,cluster_gene = TRUE) draw.funcEnrich.cluster(funcEnrich_res= res_up,top_number=30,gs_cex = 1.5,gene_cex=1.4,pv_cex=1.2,pdf_file = sprintf(&#39;%s/funcEnrich_clusterNO.pdf&#39;,analysis.par$out.dir.PLOT), cluster_gs=FALSE,cluster_gene = FALSE) QI.5: What is the biological function of the target genes of those top DA drivers ? The function of those drivers is to regulate their target genes. Then, we will ask what is the biological function of the target genes of those top DA drivers ? NetBID2 has one function draw.bubblePlot() to calculate and visualize this purpose. Before that, we only accept gene symbol as the ID for gene set annotation (for the general usage, other kinds of usage will be shown in the last part of this section), so, we need to prepare a transfer table to transfer the originalID into gene symbol for all drivers and target genes. This transfer table is already saved in the analysis.par. transfer_tab &lt;- analysis.par$transfer_tab This function has 21 options, but for the first trial, just follow the demo and the only thing to prepare is the transfer table (transfer2symbol2type). Lots of parameters are the same as in funcEnrich.Fisher(). ## draw draw.bubblePlot(driver_list= driver_list,show_label=ms_tab[driver_list,&#39;gene_label&#39;], Z_val=ms_tab[driver_list,&#39;Z.G4.Vs.others_DA&#39;], driver_type=ms_tab[driver_list,&#39;gene_biotype&#39;], target_list=analysis.par$merge.network$target_list,transfer2symbol2type=transfer_tab, bg_list=ms_tab[,&#39;geneSymbol&#39;],min_gs_size=5,max_gs_size=500,use_gs=c(&#39;H&#39;), top_geneset_number=30,top_driver_number=10, pdf_file = sprintf(&#39;%s/bubblePlot.pdf&#39;,analysis.par$out.dir.PLOT), main=&#39;Bubbleplot for top driver targets&#39;) Each column in this plot is one driver, each row is the curated gene set, and the circle in the main plot region shows the significance of the target genes for the driver in the corresponding gene set. The size of the circle is the intersected gene number (legend on the top) and the color of the circle represents the significance of the P-value (legend on the right). The color boxes down below the main figure are the significance of the drivers (user need to input the Z-statistics), followed by the barplots showing the target size of the driver (filtered by protein coding), and the color cicles below showing the drivers’ type (optional, if user input the driver_type). The figure could tell user that, e.g the target genes of the Group4 up-regulated driverPDE7B_SIG are significantly enriched in KEGG_AXON_GUIDANCE with 17 intersected genes and P-value at about 1e-10. Try the following script to get familiar with the options in the function. draw.bubblePlot(driver_list= driver_list,show_label=ms_tab[driver_list,&#39;gene_label&#39;], Z_val=ms_tab[driver_list,&#39;Z.G4.Vs.others_DA&#39;], driver_type=ms_tab[driver_list,&#39;gene_biotype&#39;], target_list=analysis.par$merge.network$target_list,transfer2symbol2type=transfer_tab, bg_list=ms_tab[,&#39;geneSymbol&#39;],min_gs_size=10,max_gs_size=300,use_gs=c(&#39;CP:KEGG&#39;), top_geneset_number=30,top_driver_number=30, pdf_file = sprintf(&#39;%s/bubblePlot_KEGG.pdf&#39;,analysis.par$out.dir.PLOT), main=&#39;Bubbleplot for top driver targets&#39;) # add marker gene mark_gene &lt;- c(&#39;KCNA1&#39;,&#39;EOMES&#39;,&#39;KHDRBS2&#39;,&#39;RBM24&#39;,&#39;UNC5D&#39;) ## marker for Group4 draw.bubblePlot(driver_list= driver_list,show_label=ms_tab[rownames(sig_driver),&#39;gene_label&#39;], Z_val=ms_tab[driver_list,&#39;Z.G4.Vs.others_DA&#39;], driver_type=ms_tab[driver_list,&#39;gene_biotype&#39;], target_list=analysis.par$merge.network$target_list,transfer2symbol2type=transfer_tab, bg_list=ms_tab[,&#39;geneSymbol&#39;],min_gs_size=10,max_gs_size=300,use_gs=c(&#39;CP:KEGG&#39;,&#39;CP:BIOCARTA&#39;,&#39;H&#39;), top_geneset_number=30,top_driver_number=80, pdf_file = sprintf(&#39;%s/bubblePlot_combine.pdf&#39;,analysis.par$out.dir.PLOT), main=&#39;Bubbleplot for top driver targets&#39;, mark_gene=ms_tab[which(ms_tab$geneSymbol %in% mark_gene),&#39;originalID_label&#39;],gs_cex = 1,driver_cex=1.2) Part II: for a selected interested driver QII.1: How to understand the significance of the selected driver ? GSEA plot for each driver QII.2: How to visualize the network structure of the selected driver ? target network structure for each driver, or two drivers (overlap testing) QII.3: What is the expression/activity for this selected driver in samples with different subtypes ? category plot Part III: further analysis QIII.1: What are the activities of the curated gene sets in all samples and what are the top significantly differed gene sets ? gene set-based activity analysis, including vocalno, heatmap, category and GSEA plot QIII.2: How to find drivers with significantly overlapped target genes ? bubble plot for target gene list How to modify the figures by adjusting the paramters in the draw. functions ?*",
    "url": "http://localhost:4000/docs/advanced_analysis",
    "relUrl": "/docs/advanced_analysis"
  },
  "1": {
    "id": "1",
    "title": "Driver estimation",
    "content": "Driver Estimation The purpose for this part: estimate potential drivers in a biological process and generate master tables. The full demo script for this part could be found in pipeline_analysis_demo1.R. Step0: preparations Library the installed NetBID2. # library the package library(NetBID2) This tutorial is based on the suggested pipeline design in NetBID2, and before start, some parameters need to be set. First, user need to know which network to use. If followed the tutorial in the Network construction part, user could specify the network.dir and network.project.name. network.dir &lt;- sprintf(&#39;%s/demo1/network/&#39;,system.file(package = &quot;NetBID2&quot;)) # use demo network in the package network.project.name &lt;- &#39;project_2019-02-14&#39; # The network.dir is the path for the network project, i.e the $project_main_dir/$project_name when calling the NetBID.network.dir.create() function. The network.project.name must be the project name whening calling the SJAracne.prepare() function. Under the network.dir multiple network.project.name is allowed, and by specifying these two paramters simultaneously, unique network files (TF, SIG networks will be generated separately) could be obtained. In the above scripts, to ensure the testing of demo scripts in this part independently, user could use the demo network in the NetBID2 package. Next, we need to set up a main directory for saving the analysis results for this part, project_main_dir. User could choose to use the same directory as in the network construction. And the project name project_name should also be settled. Similarly, the main directory could have multiple projects under the path, separeted by the project_name as the name for the sub-directory. So user could use the same main directory for another project. But project related files with the same project_main_dir and project_name will be covered. So, in the script below, user could add a time tag in the project_name to avoid this by accident. #set up paramters project_main_dir &lt;- &#39;test/&#39; ### user defined main directory for the project, one main directory could have multiple projects, separeted by project name current_date &lt;- format(Sys.time(), &quot;%Y-%m-%d&quot;) ## current date for project running, suggested to add the time tag project_name &lt;- sprintf(&#39;driver_%s&#39;,current_date) ## project name for the project Once decided the network.dir, network.project.name, project_main_dir and project_name, user could run NetBID.analysis.dir.create() to generate the sub-directories for the working directory, including QC/ to save QC related files, DATA/ to save RData and PLOT/ to save the visulization plots in the Advanced analysis part. Besides, a global list variable analysis.par will be returned by the function. Attention, if the current environment already has this variable, the function will do nothing, report a warning message and return the original analysis.par. ## analysis.par is very essential in the analysis, if the environment already has this parameter, strongly suggest to delete it first analysis.par &lt;- NetBID.analysis.dir.create(project_main_dir=project_main_dir, prject_name=project_name, network_dir=network.dir, network_project_name=network.project.name) Step1: load in gene expression dataset for analysis (exp-load,exp-cluster,exp-QC) Here, the analysis expression dataset need to be loaded for analysis. For demo, we used the same dataset for network construction and analysis. If so, the expression dataset has already been processed by QC steps, just load from the RData in the network.par$net.eset and save it to analysis.par$cal.eset. # if use same expression datasets as in the network construction, directly do the followings: load(sprintf(&#39;%s/DATA/network.par.Step.exp-QC.RData&#39;,network.dir)) ## RData from network construction analysis.par$cal.eset &lt;- network.par$net.eset However, in most of the cases, the datasets are not the same. User need to follow the similar steps in Network construction for expression dataset loading, QC and sample cluster checking. Save analysis.par into the RData file and give the step name to it, e.g exp-QC. The RData could be found in analysis.par$out.dir.DATA/analysis.par.Step.{exp-QC}.RData. NetBID.saveRData(analysis.par=analysis.par,step=&#39;exp-QC&#39;) What to do if the ID type is different between the network construction dataset and analysis dataset ? It is strongly recommended that the main ID should be the ID type in the network construction dataset ! The purpose of NetBID2 is to infer potential drivers in a biological process. The driver is defined as the source node in the network and its activity is calculated based on the network structure (its target nodes). If one gene does not exist in the pre-generated network, it will not be used in the following analysis. On the contrary, if one driver does not exist in the analyis expression dataset, it can still has its activity and could be used in the following analysis. So, we strongly recommend to align the ID type from the expression dataset to the network construction dataset by using update_eset.feature() and ID transfer table could be obtained from GPL files or use get_IDtransfer() or get_IDtransfer_betweenSpecies(). The most complicated condition is that the level of network construction ID type and the analysis expression dataset is different (e.g transcript level Vs. gene level). update_eset.feature() could deal with such conditions by setting the distribute_method and merge_method. But be careful by doing so and try to avoid such condition ! Step2: read in network files and activity calculation (act-get) Before start, load the RData from the previous step if user want to re-run the following steps or re-open the R session. Remember to set the temporary analysis.par if re-open the R session and analysis.par$out.dir.DATA will be used to find the correct RData file. No need to run this if continue working from the previous step. ## load from RData #analysis.par &lt;- list() #analysis.par$out.dir.DATA &lt;- &#39;test//driver_2019-05-06//DATA/&#39; NetBID.loadRData(analysis.par=analysis.par,step=&#39;exp-QC&#39;) Firstly, get the network generated by SJAracne. If followed the pipeline, the file path will be analysis.par$tf.network.file and analysis.par$sig.network.file. Use get.SJAracne.network() to read in the network information. If not followed the pipeline, it is also working by directly input the file path here. # get network info ! three list(network_dat, target_list, igraph_obj) analysis.par$tf.network &lt;- get.SJAracne.network(network_file=analysis.par$tf.network.file) analysis.par$sig.network &lt;- get.SJAracne.network(network_file=analysis.par$sig.network.file) This function aims to read in network files generated by SJAracne and save the network information into three lists, network_dat is a data.frame to save all the information in the network file; target_list is a list for containing the target genes’ information for the drivers. The names for the list is the driver name and each object in the list is a data.frame to save the target genes. igraph_obj is an igraph object to save the network, it is a directed, weighted network. The function will set two edge attributes to the igraph_obj, weight is the mutual information (MI) values and sign is the sign for the spearman value to indicate positive regulation (1) or negative regulation (-1). The network dataset could be updated by using update_SJAracne.network(). This function allows user to filter drivers or to add drivers without edges by setting all_possible_drivers. Similar for targets by all_possible_targets. Statistical filteration is also allowed by setting min_MI, max_p.value, min_spearman_value, min_pearson_value and the attribute of the network by setting directed and weighted. Generate an html QC report file for the network file with the igraph_obj. draw.network.QC(analysis.par$tf.network$igraph_obj,outdir=analysis.par$out.dir.QC,prefix=&#39;TF_net_&#39;) draw.network.QC(analysis.par$sig.network$igraph_obj,outdir=analysis.par$out.dir.QC,prefix=&#39;SIG_net_&#39;) The QC report files are generated for TF network and SIG network. Basic statistics including size, diameter and several kinds of centrality will be calculated. Scale free distrbution will be checked as well. Secondly, merge these two networks by merge_TF_SIG.network(). User could choose to merge the network first by merge_TF_SIG.network() and calculate driver activity based on the merged network or calculate the activity separately for TF and SIG network first and merge the activity results later by merge_TF_SIG.AC(). Both strategy will get the same final results. Drivers in the analysis.par$merge.network will have suffix of ‘_TF’ and ‘_SIG’ to indicate the driver type. One driver may have both ‘_TF’ and ‘_SIG’, but sometimes may have slightly different following results due to the network source. # merge network first analysis.par$merge.network &lt;- merge_TF_SIG.network(TF_network=analysis.par$tf.network,SIG_network=analysis.par$sig.network) Thirdly, get the activity matrix for all possible drivers by cal.Activity(). Activity will be used to estimate the driver’s performance in a biological process, beside the expression level. Basic idea to get driver’s activity is to estimate the cumulative effect on its targets. The summarization strategy could be ‘mean’, ‘weighted mean’, ‘maxmean’ and ‘absmean’, in which the weighted in the weighted mean is the MI (mutual information) value * sign of correlation (use the spearman correlation sign). If set std=TRUE, the expression matrix will be Z-transformed before calculating the activity. Higher expression of its positively regulated genes and lower expression of its negatively regulated genes indicate higher activity for this driver in the sample (if set ‘weighted mean’ as the calculation strategy). # get activity matrix ac_mat &lt;- cal.Activity(target_list=analysis.par$merge.network$target_list,cal_mat=exprs(analysis.par$cal.eset),es.method=&#39;weightedmean&#39;) Consider that the activity matrix is similar as the expression matrix that each row represents a driver with each column a sample. The value in the matrix is the activity level for the driver in the corresponding sample. Thus, we will also use the eSet class to save the data information. The phenotype information for the activity matrix is the same as for the analysis expression dataset. analysis.par$merge.ac.eset &lt;- generate.eset(exp_mat=ac_mat,phenotype_info=pData(analysis.par$cal.eset)[colnames(ac_mat),], feature_info=NULL,annotation_info=&#39;activity in net-dataset&#39;) Finally, use draw.eset.QC() to get the QC report for the analysis.par$merge.ac.eset. Check QC for AC. All functions related with eSet class manipulation are also applicable for analysis.par$merge.ac.eset. # QC plots draw.eset.QC(analysis.par$merge.ac.eset,outdir=analysis.par$out.dir.QC,intgroup=NULL,do.logtransform=FALSE,prefix=&#39;AC_&#39;) Save analysis.par to the RData file by NetBID.saveRData(). # save to RData NetBID.saveRData(analysis.par=analysis.par,step=&#39;act-get&#39;) Why study driver’s activity ? Drivers, such as transcription factors (TF) bind to the enhancer or promoter regions of the target genes and regulate their expression level. Once the TF has been synthesized, there are still many steps between mRNA translation of a TF and the actual transcriptional regulation of target genes. And the activity will be controlled by lots of following processes, such as: nuclear localization (need to be directed into nucleus), activation through signal-sensing domain (e.g ligand binding or post-translational modification: methylated, ubiquinated or phosphorylated, phosphorylations are often necessary for dimerization and binding to the target gene’s promoter), access to DNA-binding site (epigenetic feature of the genome), and interaction with other cofactors or TFs (form a complex). Thus, sometimes the expression trend and the activity pattern of the driver may be violated. Due to some ‘hidden’ effect, the activity of a driver may be essential in regulating the process while the expression level may not show significant difference in the process. Step3: get differentiated expression/differentiated activity for all possible drivers (act-DA) Load the RData from the previous step if user want to re-run the following steps or re-open the R session. Remember to set the temporary analysis.par if re-open the R session and analysis.par$out.dir.DATA will be used to find the correct RData file. No need to run this if continue working from the previous step. ## load from RData #analysis.par &lt;- list() #analysis.par$out.dir.DATA &lt;- &#39;test//driver_2019-05-06//DATA/&#39; NetBID.loadRData(analysis.par=analysis.par,step=&#39;act-get&#39;) The main purpose of this step is to get significantly differentiated expression (DE) and activity (DA) for all possible drivers between a specific process. Here, NetBID2 provides two functions getDE.BID.2G() and getDE.limma.2G() to assist the analysis between two groups (G1 Vs. G0). User only need to get the sample list for G1 and G0 and specificy the name of G1_name and G0_name to use these two functions. getDE.BID.2G() will use the bayesian inference strategy to get the DE and DA, if user choose method=&#39;Bayesian&#39;, the calculation will take more time compared with method=&#39;MLE&#39;. Ordinal phenotype condition is complicated and user could directly call bid() or functions in limma() to analyze. In the demo script below, user could get DE/DA for drivers between G4.Vs.WNT and G4.Vs.SHH. Each comparison must specify a clear name, and results will be saved into analysis.par$DE and analysis.par$DA. The comparison names will be displayed in the final master table. # generate a list for multiple comparisons analysis.par$DE &lt;- list() analysis.par$DA &lt;- list() # get compared sample names phe_info &lt;- pData(analysis.par$cal.eset) G1 &lt;- rownames(phe_info)[which(phe_info$`subgroup`==&#39;G4&#39;)] # get sample list for G1 # G4 Vs. WNT comp_name &lt;- &#39;G4.Vs.WNT&#39; G0 &lt;- rownames(phe_info)[which(phe_info$`subgroup`==&#39;WNT&#39;)] # get sample list for G0 DE_gene_bid &lt;- getDE.BID.2G(eset=analysis.par$cal.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;WNT&#39;) DA_driver_bid &lt;- getDE.BID.2G(eset=analysis.par$merge.ac.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;WNT&#39;) # save to analysis.par analysis.par$DE[[comp_name]] &lt;- DE_gene_bid analysis.par$DA[[comp_name]] &lt;- DA_driver_bid # G4 Vs. SHH comp_name &lt;- &#39;G4.Vs.SHH&#39; G0 &lt;- rownames(phe_info)[which(phe_info$`subgroup`==&#39;SHH&#39;)] # get sample list for G0 DE_gene_bid &lt;- getDE.BID.2G(eset=analysis.par$cal.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;SHH&#39;) DA_driver_bid &lt;- getDE.BID.2G(eset=analysis.par$merge.ac.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;SHH&#39;) # save to analysis.par analysis.par$DE[[comp_name]] &lt;- DE_gene_bid analysis.par$DA[[comp_name]] &lt;- DA_driver_bid If user want to combine the results from multiple comparisons, combineDE() could be applied just by creating a DE_list containing all the comparisons ready for merge. The output will be a list of DE/DA results, with one more component named “combine” that include the combined results. Give a comp_name and save into analysis.par$DE and analysis.par$DA. ## G4 Vs. others # combine the above two comparisons comp_name &lt;- &#39;G4.Vs.otherTwo&#39; DE_gene_comb &lt;- combineDE(DE_list=list(WNT=analysis.par$DE$`G4.Vs.WNT`,SHH=analysis.par$DE$`G4.Vs.SHH`)) DA_driver_comb &lt;- combineDE(DE_list=list(WNT=analysis.par$DA$`G4.Vs.WNT`,SHH=analysis.par$DA$`G4.Vs.SHH`)) analysis.par$DE[[comp_name]] &lt;- DE_gene_comb$combine analysis.par$DA[[comp_name]] &lt;- DA_driver_comb$combine User could use draw.combineDE() to visualize the top significant DE/DA combining results compared with previous ones. draw.combineDE(DE_gene_comb) draw.combineDE(DE_gene_comb,pdf_file=sprintf(&#39;%s/combineDE.pdf&#39;,analysis.par$out.dir.PLOT)) draw.combineDE(DA_driver_comb) draw.combineDE(DA_driver_comb,pdf_file=sprintf(&#39;%s/combineDA.pdf&#39;,analysis.par$out.dir.PLOT)) Also, user could choose to combine the sample list first and call DE/DA between the two sample lists. The results may be different from the above combineDE strategy as they are different in the statistical hypothesis stating. # combine the sample list comp_name &lt;- &#39;G4.Vs.others&#39; G0 &lt;- rownames(phe_info)[which(phe_info$`subgroup`!=&#39;G4&#39;)] # get sample list for G0 DE_gene_bid &lt;- getDE.BID.2G(eset=analysis.par$cal.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;others&#39;) DA_driver_bid &lt;- getDE.BID.2G(eset=analysis.par$merge.ac.eset,G1=G1,G0=G0,G1_name=&#39;G4&#39;,G0_name=&#39;others&#39;) # save to analysis.par analysis.par$DE[[comp_name]] &lt;- DE_gene_bid analysis.par$DA[[comp_name]] &lt;- DA_driver_bid When finished, save to RData. # save to RData NetBID.saveRData(analysis.par=analysis.par,step=&#39;act-DA&#39;) Now, for the calculation part, we have obtained the top DA/DE list, we could directly draw the statistics for them (by default the top 30 drivers will be displayed): draw.NetBID(DA_list=analysis.par$DA,DE_list=analysis.par$DE,main_id=&#39;G4.Vs.others&#39;) draw.NetBID(DA_list=analysis.par$DA,DE_list=analysis.par$DE,main_id=&#39;G4.Vs.others&#39;,pdf_file=sprintf(&#39;%s/NetBID_TOP.pdf&#39;,analysis.par$out.dir.PLOT),text_cex=0.8) User could choose which column to display in DA/DE results, check ?draw.NetBID for detailed instruction. ATTENTION for real practice, user may choose to display one comparison result, and the input of DA_list and DE_list must be the list class with names on it. Step4: generate master table (ms-tab) Load the RData from the previous step if user want to re-run the following steps or re-open the R session. Remember to set the temporary analysis.par if re-open the R session and analysis.par$out.dir.DATA will be used to find the correct RData file. No need to run this if continue working from the previous step. ## load from RData #analysis.par &lt;- list() #analysis.par$out.dir.DATA &lt;- &#39;test//driver_2019-05-06//DATA/&#39; NetBID.loadRData(analysis.par=analysis.par,step=&#39;act-DA&#39;) Here, the main purpose is to generate the final master table for all possible drivers. User need to prepare: Use db.preload() to load in pre-saved TF/SIG gene’s information by setting the use_level. Get the list of comparison names use_comp for output in the master table, if all, could use all_comp &lt;- names(analysis.par$DE) to get them. The DE and DA results, if followed the above pipeline, just the analysis.par$DE and analysis.par$DA. The network target list file, i.e analysis.par$merge.network$target_list. The TF/SIG list tf_sigs, will be in the global environment if run db.preload(). The column name for Z statistics (z_col), for the output of getDE.limma.2G() and getDE.BID.2G(), it will be Z-statistics. Other column names wish to display in the final master table, e.g logFC, P.Value. main_id_type, this may be the only important parameter need to set here if followed the above pipeline. Check ID conversion section for the detailed description of the id types. transfer_tab, the transfer table for ID conversion, could be obtained by get_IDtransfer2symbol2type(). If NULL, will automatically get the transfer table within the function if the main_id_type is not in the column names of ‘tf_sigs’. User could also generate their own transfer table if do not want to use BioMart. column_order_stratey, an option to order the columns in the mater table, if set to type, the columns will be ordered according to the column type; if set to comp, the columns will be ordered according to the comparisons. # load db db.preload(use_level=&#39;gene&#39;,use_spe=&#39;human&#39;,update=FALSE) # generate master table all_comp &lt;- names(analysis.par$DE) ## get all comparison name for output # prepare transfer table (optinal) use_genes &lt;- unique(c(analysis.par$merge.network$network_dat$source.symbol,analysis.par$merge.network$network_dat$target.symbol)) transfer_tab &lt;- get_IDtransfer2symbol2type(from_type = &#39;external_gene_name&#39;,use_genes=use_genes) ## get transfer table !!! analysis.par$transfer_tab &lt;- transfer_tab # generate master table analysis.par$final_ms_tab &lt;- generate.masterTable(use_comp=all_comp,DE=analysis.par$DE,DA=analysis.par$DA, network=analysis.par$merge.network$target_list, tf_sigs=tf_sigs,z_col=&#39;Z-statistics&#39;,display_col=c(&#39;logFC&#39;,&#39;P.Value&#39;), main_id_type=&#39;external_gene_name&#39;) Note: There may exist some drivers only have activity but no expression level, this is due to the difference between the network-construction dataset and analysis dataset mentioned above. Finally, output the master table into an excel file. Basic usage is just input the master table data frame into out2excel(). Marker genes mark_gene could also be highlighted. mark_strategy could be chosen from ‘color’ and ‘add_column’. ‘Color’ means the mark_gene will be displayed by its background color; ‘add_column’ means the mark_gene will be displayed in separate columns with content TRUE/FALSE indicating whether the genes belong to each mark group. Check ?out2excel for detailed usage description. Here, we create a list of MB subtype specific marker genes. The color could be random generated by get.class.color() or to user specified ones. Here, we could set up the mark_col as MB subtypes have pre-definied color codes. # output into excel files out_file &lt;- sprintf(&#39;%s/%s_ms_tab.xlsx&#39;,analysis.par$out.dir.DATA,analysis.par$project.name) # can add marker gene mark_gene &lt;- list(WNT=c(&#39;WIF1&#39;,&#39;TNC&#39;,&#39;GAD1&#39;,&#39;DKK2&#39;,&#39;EMX2&#39;), SHH=c(&#39;PDLIM3&#39;,&#39;EYA1&#39;,&#39;HHIP&#39;,&#39;ATOH1&#39;,&#39;SFRP1&#39;), G4=c(&#39;KCNA1&#39;,&#39;EOMES&#39;,&#39;KHDRBS2&#39;,&#39;RBM24&#39;,&#39;UNC5D&#39;)) #mark_col &lt;- get.class.color(names(mark_gene)) # this will randomly generate color code mark_col &lt;- list(G4=&#39;green&#39;,&#39;WNT&#39;=&#39;blue&#39;,&#39;SHH&#39;=&#39;red&#39;) out2excel(analysis.par$final_ms_tab,out.xlsx = out_file,mark_gene,mark_col) Download the master table excel file ms_tab.xlsx to study the organization of the master table. Save the analysis.par to the RData file. This file contains all information for this project, which could be used for the Advanced analysis part and NetBID2 shiny server. The analysis.par list need to include 13 components (main.dir, project.name, out.dir, out.dir.QC, out.dir.DATA, out.dir.PLOT, merge.network, cal.eset, merge.ac.eset, DE, DA, final_ms_tab, transfer_tab) in order to run in the shiny server. Strongly suggest to save the RData file in this step ! # save to RData NetBID.saveRData(analysis.par=analysis.par,step=&#39;ms-tab&#39;) How to read and use the master table ? out2excel() could output multiple master tables in different excel sheet. In each master table, it is divided into three parts: The first six columns are gene_label, geneSymbol, originalID, originalID_label, funcType and Size gene_label is the driver’s gene symbol or transcript symbol with suffix ‘_TF’ or ‘_SIG’ to indicate the driver’s type. This column is often used for display as gene/transcript symbol is the most common accpeted gene ID for communication. geneSymbol is the driver’s gene symbol or transcript symbol. originalID is the original ID type used in network construction, which should match the ID type in analysis.par$cal.eset, analysis.par$DE. originalID_label is the original ID type with suffix ‘_TF’ or ‘_SIG’, which should match the the ID type in analysis.par$merge.network, analysis.par$merge.ac.eset,analysis.par$DA. originalID_label is the only ensured unique ID for each row !!! funcType is the ‘TF’ or ‘SIG’ used to indicate the driver’s type. Size is the target size for the driver. The main columns are named by $prefix.$comp_name_{DA or DE}, in which the prefix could be Z, P.Value, logFC, AveExpr to indicate the column’s data type. comp_name is the comparison name in DA/DE. Columns of Z statistics will be automatically marked by the background color to indicate their significance. The next 13 columns (start from ensembl_gene_id to refseq_mrna) are the information for the genes. The last columns (optional) will be the marker information if set mark_strategy=&#39;add_column&#39;. User could filter by the target size, sort the columns with Z-statistics to get top significant drivers. OR, follow the tutorial in Advanced analysis part for analyze and visualization. Finish driver estimation part !!! Cheers !!!",
    "url": "http://localhost:4000/docs/driver_estimation",
    "relUrl": "/docs/driver_estimation"
  },
  "2": {
    "id": "2",
    "title": "NetBID2",
    "content": "NetBID2: Network-based Bayesian Inference of Drivers. Version 2 This is the documentation for the usage of NetBID2. Get started now View it on GitHub Overview NetBID is a systems biology tool called data-driven network-based Bayesian inference of drivers, by integrating data from transcriptomics,proteomics and phosphoproteomics. The drivers could be transcription facotrs (TF) or signaling factors (SIG). NetBID2 is the second version of NetBID, which not only covers the main functions of NetBID, but also provides plenty of supporting functions and suggested workflow to finish a NetBID2-based analysis: Provide data processing functions to assist Expression matrix pre-processing and quality assessment SJAracne-based network construction Activity calculation for drivers and gene sets Estimation of differentiated expressed genes or differentiated activated drivers Generation of master table for drivers Provide visualization functions to assist Unsupervised clustering for samples and comparison with known labels Display of a list of interested drivers, the profile of the significance and the feature of the target genes Display of a specific driver, the profile of the significance, the feature of the target genes and the detailed network structure Provide supporting functions to assist Gene/transcript ID conversion Gene function enrichment analysis &amp; result visualization Data and pipeline management Getting started Dependencies R, version &gt;= 3.4.0 Pre-request R packages Quick start: install R packages (NetBID2) install the R packages from github (not published yet) library(devtools) install_github(&quot;jyyulab/NetBID-dev&quot;,ref=&#39;master&#39;) OR, download the released source package from NetBID2_0.1.1.tar.gz and local install install.packages(&#39;NetBID2_0.1.1.tar.gz&#39;,repos=NULL) Design manual The manual for all functions in NetBID2 could be obtained from NetBID2_0.1.1.pdf. All functions have the demo scripts. All 67 invokable functions could be grouped as shown in the figure below: NetBID2 has four functions focusing on suggested pipeline (not required): NetBID.network.dir.create() will generate a working directory structure for the network construction part in NetBID2. This function aims to assist researchers to organize the working directory. NetBID.analysis.dir.create() will generate a working directory structure for the driver analysis part in NetBID2. This function aims to assist researchers to organize the working directory. NetBID.saveRData() save the dataset of one designated step the step into file. NetBID.loadRData() load the dataset of one designated step from file. Users could save two complicate list object, network.par in the network construction part and analysis.par in the driver analysis part, into the data directory (network.par$out.dir.DATA or analysis.par$out.dir.DATA), with the name of the RData marked by step name. The two lists could make user to save the whole related dataset in each step NetBID.saveRData() and easy to get them back by using NetBID.loadRData(). The RData saved from each step could be used to run the following analysis without repeating the former steps. The pipeline steps are suggested in the figure below with detailed component for the list object in the final step in the two parts: Strongly suggest new users to follow the pipeline to manage the analysis project. The pipeline is included in the tutorial below. User could follow the demo in the tutorial for better understanding the design. Most of the functions in NetBID2 are not strictly dependent on the pipeline object, user could try to learn the usage of each function by running the example in each function and prepare the required input by themselves. Tutorial We choose the demo dataset from GEO database: GSE116028. This dataset contains microarray data for 13 adult medulloblastoma (MB) samples. Three subgroups of adult MB were identified by distinct expression profiles, clinical features, pathological features, and prognosis, including 3 SHH, 4 WNT, and 6 Group4. From them, Group4 tumors in adult had significantly worse progression-free and overall survival compared with tumors of the other molecular subtypes. Here, we want to find potential hidden drivers in Group4 compared with the other subtypes by using NetBID2, for which may be related with the specific clinical feature for Group4 MB. Though the dataset in the tutorial is microarray, we will include the usage of processing RNASeq dataset in each step. The tutorials are divided by three ordered and relatively independent parts as follows: Network construction Driver estimation (master table generation) Advanced analysis (result visualization) About the project For the detailed description of NetBID algorithm, please refer our lab page View Yu Lab@St. Jude. License Distributed by an MIT license.",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },
  "3": {
    "id": "3",
    "title": "Network construction",
    "content": "Network Construction The purpose for this part: generate a gene regulatory network based on a transcriptomic datasets. The full demo script for this part could be found in pipeline_network_demo1.R. Step0: preparations Before start, we need to library the installed NetBID2. # library the package library(NetBID2) This tutorial is based on the suggested pipeline design in NetBID2. So, we need to set up a main directory for the project in project_main_dir. The main directory could have multiple projects under the path, separeted by the project_name as the name for the sub-directory. So user could use the same main directory for another project. But project related files with the same project_main_dir and project_name will be covered. So, in the script below, user could add a time tag in the project_name to avoid this by accident. #set up paramters project_main_dir &lt;- &#39;test/&#39; ### user defined main directory for the project, one main directory could have multiple projects, separeted by project name current_date &lt;- format(Sys.time(), &quot;%Y-%m-%d&quot;) ## current date for project running, suggested to add the time tag project_name &lt;- sprintf(&#39;project_%s&#39;,current_date) ## project name for the project Once decided the project_main_dir and project_name, user could run NetBID.network.dir.create() to generate the sub-directories for the working directory, including QC/ to save QC related files, DATA/ to save RData and SJAR/ to save data for running SJARACNe. Besides, a global list variable network.par will be returned by the function. Attention, if the current environment already has this variable, the function will do nothing, report a warning message and return the original network.par. ## network.par is very essential in the analysis, if the environment already has this parameter, strongly suggest to delete it first network.par &lt;- NetBID.network.dir.create(project_main_dir=project_main_dir,prject_name=project_name) ## create working directory Step1: load in gene expression datasets for network construction (exp-load) Here, we use same demo dataset for network construction and following analysis (Check the The choice of expression dataset for network construction section below). This dataset could be directly downloaded from GEO database by input the GSE ID and GPL ID. If set getGPL=TRUE, will download the gene annotation file. The output of this function will be the eSet class object and will save the RData into out.dir. Next time by running this function, it will try to load the RData in the out.dir/{GSE}_{GPL}.RData first (if update=FALSE). # from GEO, need to provide GSE and GPL net_eset &lt;- load.exp.GEO(out.dir=network.par$out.dir.DATA,GSE=&#39;GSE116028&#39;,GPL=&#39;GPL6480&#39;,getGPL=TRUE,update=FALSE) Optional: User could choose to update the feature data frame in the eSet object by update_eset.feature(). This function allows user to change the main ID from from_feature to to_feature by inputting the transfer table use_feature_info and choosing the merge_method. # ID conversion, or merge transcript level to expression level, use_feature_info can be other dataframe info; optional; net_eset &lt;- update_eset.feature(use_eset=net_eset,use_feature_info=fData(net_eset),from_feature=&#39;ID&#39;,to_feature=&#39;GENE_SYMBOL&#39;,merge_method=&#39;median&#39;) ### !!! need modify Optional: User could choose to update the phenotype data frame in the eSet object by update_eset.phenotype(). This function allows user to get phenotype information from the data frame use_phenotype_info by indicating the column that matched the sample name. The use_col could be used to tell the function which column in use_phenotype_info will be kept. If set to ‘auto’, wil extract columns with unique sample feature ranges from 2 to sample size-1. If set to ‘GEO-auto’, will extract columns: ‘geo_accession’,’title’,’source_name_ch1’,and columns end with ‘:ch1’. # select phenotype columns or user add phenotype info; optional net_eset &lt;- update_eset.phenotype(use_eset=net_eset,use_phenotype_info=pData(net_eset),use_sample_col=&#39;geo_accession&#39;,use_col=&#39;GEO-auto&#39;) Now, we need to check the data quality of the eSet by draw.eset.QC(). The QC report html mainly contains four parts, heatmap, pca, density and meansd. The intgroup could be used to indicate which column from the fData(eset) will be used in the plot (heatmap, pca, density). If set to NULL, will automatcially extract all possible groups by get_int_group(). For the usage of draw.eset.QC, pandoc is required for generate_html=TRUE. If pandoc_available()=FALSE, please install pandoc and set environment of pandoc by Sys.setenv(RSTUDIO_PANDOC=installed path). # QC for the raw expdatasets # if intgroup==NULL, will auto get intgroup # prefix: prefix for the pdf files draw.eset.QC(network.par$net.eset,outdir=network.par$out.dir.QC,intgroup=NULL,do.logtransform=FALSE,prefix=&#39;beforeQC_&#39;) What to check for the QC report html before_QC.html ? The number of samples and genes (probes/transcripts/…); All samples will be clustered by the expression pattern from all genes, check possible mis-labeled samples; The density plots show the range and distribution for the expression values, may judge whether the original dataset has been log transformed; The meansd plots show the relationship between the mean and standard deviation of the genes, used to verify whether there is a dependence of the standard deviation (or variance) on the mean. Now, basic processing steps are finished for the input expression dataset. Save it to network.par. # add the variable into network.par, very essential ! network.par$net.eset &lt;- net_eset Save network.par into the RData file and give the step name to it, e.g exp-load. The RData could be found in network.par$out.dir.DATA/network.par.Step.{exp-load}.RData. # save to RData NetBID.saveRData(network.par = network.par,step=&#39;exp-load&#39;) The choice of expression dataset for network construction For a NetBID2 project, the analysis expression dataset is selected first to assist the investigation of a biological story. The network construction expression dataset could be the same as the analysis expression dataset but need to consider some other factors. The theory of using expression dataset to infer gene regulatory networks is based on SJARACNe. It uses an information theoretic approach to eliminate the majority of indirect interactions inferred by co-expression methods. More samples, higher sensitivity and precision will be obtained by experiment. Typically, more than 100 samples is a better choice. Large size public datasets from the same tissue, cell line or biological background as the analysis dataset are recommended. User could search the databases such as GEO, TCGA. Computational inferred networks will surely have false positive edges, especially for those with relative small mutual information (MI) score. Functions related with network processing will be described in the Driver estimation part. Once a high quality network is generated, user could put them into a common shared place that multiple projects with similar biological background could rely on that. The demo used in the tutorial actually is not a good network construction expression dataset in real practice. Just used to assist user get familar with the procedure of NetBID2. Input RNASeq dataset Another two functions can be applied to load expression dataset from RNASeq, load.exp.RNASeq.demo() and load.exp.RNASeq.demoSalmon(). BUT this two function are just demo functions, which do not support complicated options in tximport() and DESeq(). Besides, the output format may be different by using different dataset as reference that these two load functions may not work well. Suggest to use the original functions if have some experience of coding. If try to use load.exp.RNASeq.demo() and load.exp.RNASeq.demoSalmon(), be ATTENTION to the return_type option in the functions. ‘txi’ is the output of tximport(), a simple list containing matrices: abundance, counts, length. ‘counts’ is the output of raw count matrix. ‘tpm’ is the output of raw tpm. ‘dds’ is the DESeqDataSet class object, the data has been processed by DESeq(). ‘eset’ is the ExpressionSet class object, the expression data matrix has been processed by DESeq(), vst(). Default is ‘tpm’. If user do not choose ‘eset’, the output will not be directly used in the following scripts in the tutorial. Check the Input expression matrix section below. Input expression matrix If the user decide to prepare the expression matrix by themselves. The eSet object could be directly obtained by using generate.eset(). For example for RNASeq dataset with ‘tpm’ as the output: #tpm &lt;- load.exp.RNASeq.demo(XXX) tmp_mat &lt;- log2(tpm) tmp_eset &lt;- generate.eset(exp_mat = tmp_mat, phenotype_info = NULL,feature_info = NULL, annotation_info = &quot;&quot;) For the option of generate.eset(), if phenotype_info = NULL, a one column named with ‘group’ will be automatically generated. if feature_info = NULL, a one column named with ‘gene’ will be automatically generated. Step2: normalization for the expression dataset (exp-QC) Before start, load the RData from the previous step if user want to re-run the following steps or re-open the R session. Remember to set the temporary network.par if re-open the R session and network.par$out.dir.DATA will be used to find the correct RData file. No need to run this if continue working from the previous step. # load from RData #network.par &lt;- list() #network.par$out.dir.DATA &lt;- &#39;test//project_2019-05-02//DATA/&#39; NetBID.loadRData(network.par = network.par,step=&#39;exp-load&#39;) Following basic QC steps are suggested procedure for microarray dataset, all of the steps are optional. Firstly, check the NA values in the expression dataset by counting the number of NA values for each sample and for each gene (or probes/transcripts/…). If one sample or gene with too many NA values, user could choose to remove that gene or sample or do imputation by impute.knn(). ## following QC steps are optional !!!! mat &lt;- exprs(network.par$net.eset) # remove possible NA? or imputation ? ## need to user-decide sample_na_count &lt;- apply(mat,1,function(x){length(which(is.na(x)==TRUE))}) print(table(sample_na_count)) gene_na_count &lt;- apply(mat,2,function(x){length(which(is.na(x)==TRUE))}) print(table(gene_na_count)) if(sum(sample_na_count)+sum(gene_na_count)&gt;0) mat &lt;- impute.knn(mat)$data Secondly, the log2 transformation. Sometimes it is hard to know whether the original dataset has been log2 transformed or not. Here, we provide an experienced judging threshold for the median value. This is may not be suitable for all conditions. # log2 transformation med_val &lt;- median(apply(mat,2,median));print(med_val) if(med_val&gt;16){mat &lt;- log2(mat)} Thirdly, the quantile normalization between samples. This is suggested for dealing with microarray dataset and not for RNASeq, even the log2tpm etc. # quantile normalization mat &lt;- normalizeQuantiles(mat) ## limma quantile normalization Fourthly, remove low expressed genes across nearly all samples. The suggested threshold is shown below, try to remove genes that in more than 90% samples, the expression value is lower than 5%. # remove low expressed genes, such as whether in more than 90% samples, the expression value is lower than 5% choose1 &lt;- apply(mat&lt;= quantile(mat, probs = 0.05), 1, sum)&lt;= ncol(mat) * 0.90 print(table(choose1)) mat &lt;- mat[choose1,] Now, the expression matrix has been updated, need to save into the eSet class object by using generate.eset(). Update the network.par$net.eset, generate the QC report html by draw.eset.QC() and save to RData by NetBID.saveRData(). # update eset net_eset &lt;- generate.eset(exp_mat=mat, phenotype_info=pData(network.par$net.eset)[colnames(mat),], feature_info=fData(network.par$net.eset)[rownames(mat),], annotation_info=annotation(network.par$net.eset)) network.par$net.eset &lt;- net_eset draw.eset.QC(network.par$net.eset,outdir=network.par$out.dir.QC,intgroup=NULL,do.logtransform=FALSE,prefix=&#39;afterQC_&#39;) # save to RData NetBID.saveRData(network.par = network.par,step=&#39;exp-QC&#39;) What to check for the QC report html after QC steps after_QC.html? The number of samples and genes (probes/transcripts/…), whether large amount of genes/samples are removed; All samples will be clustered by the expression pattern from all genes, check possible mis-labeled samples; The density plots show the range and distribution for the expression values, whether the low expressed genes have been removed; The meansd plots show the relationship between the mean and standard deviation of the genes, used to verify whether there is a dependence of the standard deviation (or variance) on the mean. QC for RNASeq dataset No matter what strategy is used to input the RNASeq dataset, only the fourth step ‘remove low expressed genes’ is suggested. For example, if use load.exp.RNASeq.demo() or load.exp.RNASeq.demoSalmon() and output dds, no previous normlization is required. If user use the raw count as the expression matrix, the RNASeqCount.normalize.scale() could be used to normalize the count data, followed by ‘log2 transformation’. For the fpkm(Fragments per kilobase of exon per million reads mapped ), tpm(Transcripts Per Million), cpm(Counts Per Million), the second step ‘log2 transformation’ is suggested. User is strongly suggested to judge which QC step to use for their own dataset or follow the pipeline suggested by the different calling software. Combine two datasets If user want to combine two datasets, merge_eset() could be used. If the original two datasets are generated from the same platform with the same expression gene list, no Z-transformation will be performed; otherwise Z-transformation will be performed before merging the dataset. The merged eSet will automatically generate one phenotype column named by group_col_name. By default, the function will not remove batches between the two datasets. Strongly suggest to remove the batch for microarray dataset but not for RNASeq dataset. For the RNASeq dataset, user could follow the tutorial in the Step3 for detailed sample clustering checking and re-run the code in this step. Step3: check sample cluster information, optional (exp-cluster) Before start, load the RData from the previous step if user want to re-run the following steps or re-open the R session. Remember to set the temporary network.par if re-open the R session and network.par$out.dir.DATA will be used to find the correct RData file. No need to run this if continue working from the previous step. # load from RData #network.par &lt;- list() #network.par$out.dir.DATA &lt;- &#39;test//project_2019-05-02//DATA/&#39; NetBID.loadRData(network.par = network.par,step=&#39;exp-QC&#39;) Select the most variable genes for the sample clustering analysis by IQR.filter(). In the script below, the most 50% variable genes will be used. For the IQR.filter() function, it allows user to input a list of genes (loose_gene), which can be applied to loose_thre. This is applicable when user need to keep more interested genes (e.g transcription factors) by using a looser threshold for filteration. # use most variable genes for cluster mat &lt;- exprs(network.par$net.eset) choose1 &lt;- IQR.filter(exp_mat=mat,use_genes=rownames(mat),thre = 0.5,loose_gene=NULL,loose_thre=0.1) print(table(choose1)) mat &lt;- mat[choose1,] Generate a temporary eSet and get the html QC report Cluster_QC.html. Here give a first galance of sample clustering results Vs. pre-defined sample groups. # generate tmp eset tmp_net_eset &lt;- generate.eset(exp_mat=mat, phenotype_info=pData(network.par$net.eset)[colnames(mat),], feature_info=fData(network.par$net.eset)[rownames(mat),], annotation_info=annotation(network.par$net.eset)) # QC plots draw.eset.QC(tmp_net_eset,outdir=network.par$out.dir.QC,intgroup=NULL,do.logtransform=FALSE,prefix=&#39;Cluster_&#39;) In the following scripts, user could get lots of plots. Firstly, get the phenotype information data frame pData(network.par$net.eset) and all possible phenotype classes intgroup. For each intgroup, use could choose to use draw.pca.kmeans() or draw.umap.kmeans() to display the sample clustering results between the observed label and predicted label. The prediction is performed by kmeans based on pca or umap dimension reduction results. If user use MICA for clustering, draw.MICA() also could be used for result display. The output for those functions will be the predicted label for the best k if setting return_type=&#39;optimal&#39; or the results for all_k if return_type=&#39;all&#39;. # more cluster functions (will not directly save to file, but actively layout) phe &lt;- pData(network.par$net.eset) intgroup &lt;- get_int_group(network.par$net.eset) # pca+kmeans in 2D for(i in 1:length(intgroup)){ print(intgroup[i]) pred_label &lt;- draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,intgroup[i])) } Take subgroup as an example, the following scripts will generate: use_int &lt;- &#39;subgroup&#39; pred_label &lt;- draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,use_int),plot_type=&#39;2D&#39;) This is the basic scatter plot to display the samples with color coded by observed and predicted label. The statistics in the right figure is the score between predicted label and observed label by get_clustComp(). ARI stands for ‘adjusted rand index’, which ranges from 0 to 1 with higher value indicates higher similarity. pred_label &lt;- draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,use_int),plot_type=&#39;2D.ellipse&#39;) This is the scatter plot with ellipse to cover the points belong to one class. pred_label &lt;- draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,use_int),plot_type=&#39;2D.text&#39;) This is the scatter plot with sample name directly labelled on the plot, which is useful for outlier checking. pred_label &lt;- draw.pca.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,use_int),plot_type=&#39;3D&#39;) This is the 3D scatter plot. print(table(list(pred_label=pred_label,obs_label=get_obs_label(phe, use_int)))) draw.clustComp(pred_label,obs_label=get_obs_label(phe,use_int),outlier_cex=1,low_K=10) ## display the comparison in detail This is the table to display the detailed difference between predicted label and observed label. We can see from the table here, 4 WNTs are further separated into two groups. In this demo dataset, no clear outlier samples are observed. If user find some somes need to remove, please remove the samples and re-run the exp-QC steps. Step4: prepare SJARACNE (sjaracne-prep) Before start, load the RData from the ‘exp-QC’ step if user want to re-run the following steps or re-open the R session. Remember to set the temporary network.par if re-open the R session and network.par$out.dir.DATA will be used to find the correct RData file. No need to run this if continue working from the previous step. # load from RData #network.par &lt;- list() #network.par$out.dir.DATA &lt;- &#39;test//project_2019-05-02//DATA/&#39; NetBID.loadRData(network.par = network.par,step=&#39;exp-QC&#39;) Load the transcription facotrs (TF) and signaling factors (SIG) list from database by db.preload().NetBID2 has prepared both ‘gene’ and ‘transcript’ level RData files for human. If user’s input is not human, could run db.preload() to prepare the database files. If leave main.dir=NULL, the RData will be saved to system.file(package = &quot;NetBID2&quot;)/db/. If NetBID2 is installed in a public place with no permission to user, just set main.dir to another place and remember to use the same path next time using it. For the TF and SIG list, NetBID2 has provided the files in ‘external_gene_name’ and ‘ensembl_gene_id’ ID type for human and mouse. (e.g MOUSE_SIG_ensembl_gene_id.txt in system.file(package = &quot;NetBID2&quot;)/db/). The function will automatically use those files if set TF_list=NULL or SIG_list=NULL. User could also input their own list and input by setting TF_list or SIG_list. # load database db.preload(use_level=&#39;gene&#39;,use_spe=&#39;human&#39;,update=FALSE) After loading the database, user need to set the ID attribute type use_gene_type for the input expression matrix. Check ID conversion section below for detailed description of ID conversion issue. # ID convertion, get TF/SIG list !!!! use_gene_type &lt;- &#39;external_gene_name&#39; ## this should user-defined !!! use_genes &lt;- rownames(fData(network.par$net.eset)) use_list &lt;- get.TF_SIG.list(use_genes,use_gene_type=use_gene_type) The above two steps are not required if user could get the TF_list and SIG_list with the same ID type as the expression matrix, just input them in the SJAracne.prepare(). The final step is to prepare the input for running SJAracne. User could choose to use part of the samples or use all. And in one project, multiple networks could be generated by setting different prj.name. For example, if want to generate Group4 specific network, user could choose to use samples in Group4 by setting the use.samples and give it an easily identified project name such as prj.name=&#39;Group4_net&#39;. This prj.name is important in the Driver estimation part. The IQR.thre and IQR.loose_thre will be passed to IQR.filter(). The loose_gene in this function will be the genes in TF_list and SIG_list as we want to keep more possible drivers in the network construction. In the demo network of NetBID2, in order to control the file size, the IQR.thre=0.9 and IQR.loose_thre=0.7. In real practice, IQR.thre=0.5 and IQR.loose_thre=0.1 is recommended. # select sample for analysis phe &lt;- pData(network.par$net.eset) use.samples &lt;- rownames(phe) ## use all samples, or choose to use some samples prj.name &lt;- network.par$project.name # can use other names, if need to run different use samples SJAracne.prepare(eset=network.par$net.eset,use.samples=use.samples, TF_list=use_list$tf,SIG_list=use_list$sig, IQR.thre = 0.5,IQR.loose_thre = 0.1, SJAR.project_name=prj.name,SJAR.main_dir=network.par$out.dir.SJAR) Next is to follow the message to run SJAracne. As SJAracne will consume lots of memory in running, which may be not suitable in R session, user need to follow the instructions to run SJAracne. ID conversion We will use the ID name from biomaRt. Some common attribute names are ‘ensembl_transcript_id’, ‘ensembl_gene_id’, ‘external_transcript_name’, ‘external_gene_name’, ‘hgnc_symbol’, ‘entrezgene’, ‘refseq_mrna’. If the original input is ‘ensembl_gene_id_version’ or ‘ensembl_transcript_id_version’, user could set ignore_version=TRUE to neglect the version number. ATTENTION! biomaRt will use the newest version number of GENCODE and all the ID conversion related functions db.preload(), get.TF_SIG.list(), get_IDtransfer(), get_IDtransfer2symbol2type(), get_IDtransfer_betweenSpecies() will remotely call the database from biomaRt through the web link. So, the version number may be different when running the same code at different time. get_IDtransfer(), get_IDtransfer2symbol2type(), get_IDtransfer_betweenSpecies() will output a transfer table used for get_name_transfertab(). User could use their curated one. Finish network construction part !!! Cheers !!!",
    "url": "http://localhost:4000/docs/network_construction",
    "relUrl": "/docs/network_construction"
  },
  "4": {
    "id": "4",
    "title": "Pre-requested",
    "content": "Pre-requested R packages R version &gt;= 3.4.0 The package is developed on R 3.5.1, and has been tested on 3.4.0. Following is the description for dependent R packages, mainly for developers to better understand the code in NetBID2. Users do not need to digest the information below. R package Functions1 Category Purpose Biobase - Data processing ExpressionSet class GEOquery getGEO Data processing Get expression dataset from GEO database limma - Data processing Expression data normalization impute impute.knn Data processing Data imputation tximport Data processing Data import   DESeq2 DESeqDataSetFromTximport,DESeq Data processing Data import from txi and normalization for RNASeq data ConsensusClusterPlus - Clustering Get consensus clustering results aricode clustComp Clustering For cluster comparison statistic calculation igraph - Visualization Igraph class and basic network-based calculation RColorBrewer brewer.pal Visualization Get color bar plot3D scatter3D Visualization 3D plot plotrix draw.ellipse Visualization drawing ellipse umap umap Visualization data dimension reduction and visualization vsn meanSdPlot Visualization meansd plot hexbin hexbin Visualization meansd plot ComplexHeatmap Heatmap Visualization heatmap drawing ordinal clm,clmm bid Cumulative Link Mixed Models MCMCglmm MCMCglmm bid Multivariate Generalized Linear Mixed Models arm bayesglm bid Bayesian generalized linear models reshape melt bid Melt an object into a form suitable for easy casting biomaRt - ID conversion ID conversion GSVA gsva Gene Set gene set activity calculation msigdbr - Gene Set MSigDB database openxlsx - IO Output into excel file (master table) rhdf5 H5Fopen,H5Fclose IO For hd5 formation data processing (MICA) rmarkdown render Report For generating html report file kableExtra - Report For table layout in the report file ’-‘ in the Function column represents multiple functions in the package were used in NetBID2. &#8617;",
    "url": "http://localhost:4000/docs/pre_request",
    "relUrl": "/docs/pre_request"
  }
  
}
