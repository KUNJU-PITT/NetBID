% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipeline_functions.R
\name{draw.umap.kmeans}
\alias{draw.umap.kmeans}
\title{Draw Cluster Plot Using UMAP (visulization algorithm) and Kmeans (cluster algorithm).}
\usage{
draw.umap.kmeans(mat = NULL, all_k = NULL, obs_label = NULL,
  legend_pos = "topleft", legend_cex = 0.8,
  kmeans_strategy = "basic", choose_k_strategy = "ARI",
  plot_type = "2D.ellipse", point_cex = 1, return_type = "optimal",
  main = "", verbose = TRUE, use_color = NULL, pre_define = NULL)
}
\arguments{
\item{mat}{numeric matrix, the expression matrix. Rows are genes/features, columns are samples. Columns will be clustered based on row features.}

\item{all_k}{a vector of integers, the pre-defined K-values. If NULL, will use all possible K. Default is NULL.}

\item{obs_label}{a vector of characters, the observed sample labels or categories, name of the vector is sample names.}

\item{legend_pos}{character, the legend position. Default is "topleft".}

\item{legend_cex}{numeric, giving the amount by which the text of legend should be magnified relative to the default. Default is 0.8.}

\item{kmeans_strategy}{character, K-means clustering algorithm. Users can choose "basic" or "consensus".
"consensus" is performed by \code{ConsensusClusterPlus}. Default is "basic".}

\item{choose_k_strategy}{character, method to choose the K-value. Users can choose from "ARI (adjusted rand index)", "NMI (normalized mutual information)" and "Jaccard".
Default is "ARI".}

\item{plot_type}{character, type of the plot.
Users can choose from "2D","2D.interactive", "2D.ellipse", "2D.text" and "3D". Default is "2D.ellipse".}

\item{point_cex}{numeric, giving the amount by which the size of the data points should be magnified relative to the default. Default is 1.}

\item{return_type}{character, the type of result returned. Users can choose "optimal" or "all".
"all", all the K-values in all_k will be returned.
"optimal", only the K-value yielding the optimal classification result will be returned.
Default is "optimal".}

\item{main}{character, title for the plot.}

\item{verbose}{logical, if TRUE, print out detailed information during calculation. Default is TRUE.}

\item{use_color}{a vector of color codes, colors to be assigned to each member of display label. Default is brewer.pal(9, 'Set1').}

\item{pre_define}{a vector of characters, pre-defined color codes for a certain input (e.g. c("blue", "red") with names c("A", "B")). Default is NULL.}
}
\value{
Return a vector of the predicted label (if \code{return_type} is "optimal") and a list of all possible K-values (if \code{return_type} is "all").
If plot_type='2D.interactive', will return a plotly class object for interactive display.
}
\description{
\code{draw.umap.kmeans} is a function to visualize the cluster result for the input data matrix. It is mainly used for check sample clustering result.
Warning, it is not suggested to use when sample size is small.
}
\examples{
network.par <- list()
network.par$out.dir.DATA <- system.file('demo1','network/DATA/',package = "NetBID2")
NetBID.loadRData(network.par=network.par,step='exp-QC')
mat <- Biobase::exprs(network.par$net.eset)
phe <- Biobase::pData(network.par$net.eset)
intgroup <- get_int_group(network.par$net.eset)
for(i in 1:base::length(intgroup)){
 print(intgroup[i])
 pred_label <- draw.umap.kmeans(mat=mat,all_k = NULL,obs_label=get_obs_label(phe,intgroup[i]))
 print(base::table(list(pred_label=pred_label,obs_label=get_obs_label(phe,intgroup[i]))))
}
pred_label <- draw.umap.kmeans(mat=mat,all_k = NULL,
                             obs_label=get_obs_label(phe,intgroup[i]),
                             kmeans_strategy='consensus')
## interactive display
draw.umap.kmeans(mat=mat,all_k = NULL,
               obs_label=get_obs_label(phe,'subgroup'),
               plot_type='2D.interactive',
               pre_define=c('WNT'='blue','SHH'='red','G4'='green'))
}
